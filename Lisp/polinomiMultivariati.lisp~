
(defun as-monomial (expression)
  (cond ((and (numberp (car expression)) ; caso in cui ho solo un numero esempio (4)
	      (eq nil (cdr expression)))
	 (list 'm (car expression) 0 nil))

	((eq '* (car expression))
	 (list 'm 'numero (as-variable (cdr expression))))

))

; bisogna inserire il caso (expt 4 a)
; bisogna inserire il caso (a)

; errore il caso (* 4 a) ritorna (M NUMERO (NIL))
; errore il caso (* 4 (expt 4 a)) ritorna (M NUMERO (NIL))

(defun as-variable (variables)
  (let (( variable (cond ( (listp (car variables)) ;CONDIZIONE 
			   (as-exponent (car variables)) ) ; CONDIZIONE TRUE

			 ( (and (symbolp (car variables)) (not (eq '* (car variables)))) )
			 )))

    (cond ( (eq '() (cdr variables)) (list variable) )
	  ( T (append (list variable) (as-exponent (cdr variables)))) ) ))


;  (let ((var1 init-form-1)
;	(var2 init-form-2))
;    decleration1))

(defun as-exponent (exponent)
  (cond ((and (eq 'expt (first exponent)) ;costrisci la variabile del tipo (exp 4 A) funziona 
	      (numberp (second exponent))
	      (< 0 (second exponent))
	      (symbolp (third exponent)))
	 (list 'v (list (second exponent) (third exponent))))

	((and (eq 'expt (first exponent)) ;costrisci la variabile del tipo (exp 0 5) funziona 
	      (numberp (second exponent))
	      (= 0 (second exponent))
	      (symbolp (third exponent)))
	 (list 1 ))
 ))











; funzioni di test
(defun a (exponent)
  (cond ((eq 'expt (first exponent))
	 (car exponent))))

(defun a1 (exponent)
  (cond ((numberp (second exponent))
	 (second exponent))))

(defun a2 (exponent)
  (cond ((< 0 (second exponent))
	 (second exponent))))

(defun a3 (exponent)
  (cond ((symbolp (third exponent))
	 (third exponent))))